# JVM, GC 관련

## 1. JVM이 무엇인가요?

- JVM은 Java Virtual Machine 의 약어로, 컴파일된 자바 바이트 코드를 실행하는 가상의 운영체제역할을 합니다

## 2. JVM 구조에 대해서 설명해주세요

- JVM은 크게 클래스 로더, 런타임 데이터 영역, 실행 엔진으로 나눌 수 있습니다

## 3. 클래스 로더에 대해 설명해주세요

- 클래스 로더는 런타임동안 JVM의 메소드 영역에 동적으로 Java 클래스를 로드하는 역할을 합니다. 클래스 로더는 로딩, 링크, 초기화 단계로 나뉘어져 있습니다.

## 4. 로딩, 링크, 초기화에 대해 설명해주세요

- **로딩**은 자바 바이트 코드를 메소드 영역에 저장합니다.  
  **링크**는 읽어온 클래스가 문제가 없는지 검사하고, 클래스가 필요한 메모리를 할당하고, 심볼릭 메모리 레퍼런스를 실제 레퍼런스로 교체합니다.
  **초기화**는 클래스를 적절한 값으로 초기화하며, static 필드들이 설정된 값으로 초기화합니다.

## 심볼릭 참조(symbolic reference)와 직접 참조(direct reference)

- 심볼릭 참조란 우리가 코드를 작성하면서 사용한 class, field, method의 이름을 지칭한 것을 말합니다. Resolution 단계에서 class, field, method 그리고 constant pool 의 symbolic references를 실제 메모리 주소로 변환합니다.

## 5. JVM 메모리 구조를 자세히 설명해주세요

- JVM 메모리 구조는 크게 5가지로 나눌 수 있습니다
  - 스레드마다 하나씩 생성되는 공간
    - PC 레지스터
      - 메소드 안에서 바이트 코드 몇번째 줄을 실행하고 있는지와 같은 정보를 갖고 있습니다
    - JVM 스택
      - 새로운 메소드가 호출될 때마다 push, 메소드 실행이 끝나면 pop 동작을 수행합니다
      - 각 스택 프레임에는 지역변수배열, 피연산자 등을 저장하고 있습니다
    - 네이티브 메소드 스택
      - 자바 코드가 아닌 다른 언어로 작성된 네이티브 코드를 위한 스택입니다
  - 모든 스레드가 공유하는 공간
    - 힙
      - 프로그램을 실행하면서 생성된 인스턴스를 저장하는 공간입니다
    - 메소드
      - 클래스 로더가 클래스 파일을 읽어오면 클래스 정보를 파싱하여 필드와 메소드 정보, 메소드의 바이트 코드 등을 저장하는 공간입니다
      - 런타임 상수 풀
        - 메소드 영역 중 하나입니다
        - 각 클래스와 인터페이스의 상수 뿐만 아니라, 메소드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블 입니다.
        - 어떤 메소드나 필드를 참조할 때 런타임 상수 풀을 거쳐야합니다

## 6. JVM 실행 엔진을 설명해주세요

- 실행 엔진은 메모리에 적재된 바이트 코드를 기계어로 변경하여 명령어 단위로 실행하며, 이때 인터프리터와 JIT 방식이 사용됩니다
  - 인터프리터
    - 런타임 중에 바이트 코드를 한 줄씩 읽고 실행합니다
    - 속도가 느립니다
  - JIT
    - 인터프리터의 속도 이슈를 해결하기 위해 같이 사용합니다
    - 자주 실행되는 바이트코드영역을 런타임 중에 기계어로 컴파일하여 사용합니다

## 7. Java의 실행방식을 설명해주세요

1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당 받습니다.
2. 자바 파일이 자바 컴파일러에 의해 자바 바이트코드로 변환됩니다
3. 클래스 로더를 통해 자바 바이트 코드를 JVM으로 필요한 시점에 로딩합니다.
4. 해석된 바이트 코드는 런타임 데이터 영역에 배치되고, 실행 엔진에 의해 실질적인 수행이 이루어지게 됩니다
5. 실행 과정 속에서 JVM은 필요에 따라 GC와 같은 관리 작업을 수행합니다

## 8. JVM의 특징에 대해서 설명해주세요

- Java와 OS 사이에서 중재자 역할을 수행하므로 OS와 무관하게 실행을 보장합니다  
  GC를 통해 프로그램 메모리를 관리하고 최적화합니다

## 9. JVM의 장단점을 설명해주세요

- 장점
  - Java와 OS 사이에서 중재자 역할을 수행하므로 OS와 무관하게 실행을 보장합니다
  - GC를 통해 프로그램 메모리를 자동으로 관리하고 최적화 합니다
- 단점
  - 바이트 코드를 기계어로 바꾸는 과정이 한 번의 컴파일링으로 기계어가 만들어지는 C/C++ 에 비해 속도가 느립니다. 다만 최근에는 JIT를 통해 자주 실행되는 바이트 코드 영역을 컴파일해두기 때문에 속도의 격차를 많이 줄였습니다.

## 10. GC란 무엇인가요?

- GC는 메모리 관리 기법 중 하나로, 동적으로 할당했던 메모리 영역 중 필요없게 된 영역을 해제하는 기능입니다. 여기서 동적으로 할당했던 메모리 영역은 프로그램 런타임에 사용되는 Heap 영역을 뜻하고, 필요없게 된 영역은 어떤 변수도 가리키지 않게 된 영역을 뜻합니다

## 11. GC의 장단점을 설명해주세요

- 장점
  - 메모리를 수동으로 관리하던 것에서 비롯된 에러를 예방할 수 있습니다
    - 개발자의 실수로 인한 메모리 누수, 메모리 이중 해제, 해제된 메모리 접근 등
- 단점
  - GC의 메모리 해제 타이밍을 정확히 알기 어렵습니다
  - 어떠한 메모리 영역이 해제의 대상이 될지 검사하고, 실제로 해제하는 일이 모두 오버헤드에 해당합니다

## 12. GC에서 사용하는 알고리즘은 무엇이 있고, java는 어떤 알고리즘을 사용하나요?

- GC에서 사용하는 알고리즘은 Reference Counting과 Mark And Sweep이 있고, Java에서는 후자를 선택하여 사용합니다
  - Reference Counting
    - 각각의 객체는 몇 가지 방법으로 해당 객체에 접근할 수 있는지 나타내는 Reference Count를 가지고 있고, 이 Count가 0이 된 객체를 메모리에서 해제하는 기법입니다
  - Mark And Sweep
    - Root Space(스택 변수, 정적 변수 등 Heap 영역 참조를 가리키는 공간)부터 그래프 순회를 통해 연결된 객체를 찾아내고, 연결이 끊어진 객체는 메모리에서 해제하는 기법입니다
    - Reference count가 0이 되면 자동으로 지워버리는 reference counting과 다르게 mark and sweep은 의도적으로 특정 순간에 gc를 실행해야 합니다
