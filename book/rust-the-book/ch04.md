# 소유권 이해하기

## 소유권이 뭔가요?

- 소유권(Ownership)은 러스트가 가비지컬렉터 없이 메모리 안정성을 보장하도록 해준다 
  - c, c++ -> malloc & free
    - 프로그래머가 직접 명시적으로 메모리를 할당하고 해제
  - java, python -> gabage collector
    - 가비지 컬렉터로 더이상 사용하지 않는 메모리를 정기적으로 찾음
  - rust -> ownership
    - 컴파일러가 컴파일 중에 검사할 여러 규칙을 정해 메모리를 관리하는 방식
- 소유권이란?
  - 러스트 프로그램의 메모리 관리법을 지배하는 **(컴파일 중에 검사하는)** 규칙 모음
- 소유권의 특성
  - 소유권을 위반하면 프로그램은 컴파일 되지 않는다.
  - 소유권의 어떠한 특성도 프로그램 실행 속도를 느리게 하지 않습니다.
    - 컴파일 중에 검사하는 규칙이기에 실행(런타임)에는 영향을 끼치지 않음

---

## 스택 영역과 힙 영역

- 스택과 힙은 모두 프로그램이 **런타임**에 이용하게 될 메모리 영역
- 스택은 후입선출(last in, first out)의 구조를 가짐
  - 중간이나 맨 아래에 끼워 넣는건 쉽지 않음
- 스택에 저장되는 데이터는 모두 명확하고 크기가 정해져 있어야 한다.
  - 다시말해, 크기를 알 수 없거나, 크기가 변경될 수 있는 데이터는 스택이 아닌 힙에 저장되어야함
- 데이터에 접근하는 방식에 따른 속도 차이
  - 저장시
    - 스택: 저장할 공간을 따로 찾을 필요가 없다
    - 힙: 메모리 할당자가 저장할 공간을 찾고 (공간) 예약을 해야한다
  - 접근시
    - 힙: 포인터가 가리키는 (서로 멀리 떨어진) 곳을 찾아가는 과정으로 느리다
    - 스택: 데이터가 서로 붙어 있어서 빠르다
- 사용하는 곳
  - 스택: 함수 호출시 넘겨준 값과 지역변수 => 함수 종료시 사라짐
  
---

## 소유권 규칙

- 각각의 값은 소유자(owner)가 정해져 있습니다.
- 한 값의 소유자는 동시에 여럿 존재할 수 없습니다.
- 소유자가 스코프 밖으로 벗어날 때 값은 버렵집니다.

---

## 변수의 스코프

- 스코프란?
  - 프로그램 내에서 아이템이 유효한 범위
- 예시
```rust
	{ // s는 아직 선언되지 않아서 여기서는 유효하지 않습니다.
	let s = "hello";  // 이 지점부터 s가 유효합니다.
	} // 이 스코프가 종료되었고, s가 더이상 유효하지 않습니다
```

---

## String 타입

- String 타입은 힙에 저장되면서 러스트의 데이터 정리 과정을 알아보는데 적합하다
  - 이외에도 소유권 규칙은 (힙에 저장되는) 표준 라이브러리가 제공하는 다른 타입들이나 우리가 만들 복잡한 데이터 타입에도 적용된다
  - String 타입은 문자열 리터럴과 다르게 힙에 할당된 데이터이기 때문에, 컴파일 타임에 크기를 알 수 없는 텍스트를 저장하기에 적합하다
    - 또한 문자열 리터럴은 변경할 수 없고, String 타입은 변경할 수 있다
    - 그 이유는 각 타입(문자열 리터럴, String)의 메모리 사용방식에 있다
```rust
{
    let s = "hello";    // 문자열 리터럴
    let s2 = String::from("hello"); // String
}
```

---

## 메모리와 할당

- 메모리 사용방식 
  - 문자열 리터럴: 컴파일 타임에 내용을 알 수 있으므로 텍스트(값)이 최종 **실행파일에 하드코딩**됩니다
    - 빠르고 효율적이지만 문자열이 변하지 않을 경우에만 사용가능
  - String: 힙에 메모리를 할당하는 방식. 텍스트 내용 및 크기를 변경할 수 있다
- 메모리 해제방식
  - c/c++ -> 할당받은 메모리가 필요없어지는 지점을 프로그래머가 직접 찾아 메모리 해제 코드(free)를 작성
  - java/python -> GC가 사용하지 않는 메모리를 찾아 없애준다
  - rust -> 변수가 자신이 소속된 스코프를 벗어나는 순간 자동으로 메모리를 해제한다
    - 변수가 스코프 밖으로 벗어나면 `drop`이라는 특별한 함수를 호출한다.
    - `drop`에는 직접 메모리 해제 코드를 작성해 넣을 수 있다

---

## 변수와 데이터 간 상호작용 방식: 이동

```rust
{
    let s1 = String::from("hello");
    let s2 = s1;
}
```
- String이 저장되는 방식
  - `String`은 다음과 같이 부분으로 이루어져있음
    - 스택
      - 1. 문자열 내용("hello")이 들어 있는 (힙)메모리을 가리키는 **포인터**
      - 2. 문자열 길이
      - 3. 메모리 용량
    - 힙
      - 문자열 내용("hello")
- 위에서 `s2`에 `s1`을 대입하면 `String`의 스택 데이터(포인터, 길이, 용량) 값이 복사된다.
- 앞서 언급한 것처럼 변수가 스코프 밖으로 벗어날 때 러스트에서는 자동으로 `drop` 함수를 호출하여 해당 변수가 사용하는 힙 메모리를 제거한다
- `s2`, `s1`이 스코프 밖으로 벗어날 때 각각 (힙)메모리를 해제하게 되면 중복해제(double free) 에러가 발생
- 위의 버그를 피하기 위해서 `let s2 = s1;` 라인 뒤로는 `s1`이 더이상 유효하지 않다고 판단
```rust
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1); // compile error
```
- 이동(move)란 기존의 변수를 무효화한다

---

## 변수와 데이터 간 상호작용 방식: 클론

```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
```
- `String`의 스택 데이터'만' 아니라 힙 데이터까지 복사하고 싶을 땐 `clone` 메서드를 사용

---

## 스택에만 저장되는 데이터: 복사

```rust
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
```
- 이동(move) 되지 않고, 복사가 되고 대입연산 후에도 사용가능
  - 스택에 저장되는 타입에 달아 놓을 수 있는 `Copy` 트레이트가 존재
  - `Copy` 트레이트가 구현된 타입의 변수는 이동(move)되지 않고, 자명하게 복사된다
- `Drop` 트레이트가 구현된 경우엔 `Copy` 트레이트를 어노테이션 할 수 없다
- `Copy`가 가능한 타입들의 일부
  - 정수형 타입
  - 논리자료형 bool
  - 부동소수점 타입
  - 문자 타입
  - `Copy` 가능한 타입만으로 구성된 튜플

---

## 소유권과 함수

- 함수로 값을 전달하는 메커니즘은 변수에 값을 대입할 때와 유사
  - 함수에 변수를 전달하면 이동(move) 또는 복사(Copy)가 일어난다
```rust
fn main() {
    let s = String::from("hello");  // s가 스코프 안으로 들어옵니다

    takes_ownership(s);             // s의 값이 함수로 이동됩니다...
                                    // ... 따라서 여기서는 더 이상 유효하지 않습니다

    let x = 5;                      // x가 스코프 안으로 들어옵니다

    makes_copy(x);                  // x가 함수로 이동될 것입니다만,
                                      // i32는 Copy이므로 앞으로 계속 x를
                                      // 사용해도 좋습니다

} // 여기서 x가 스코프 밖으로 벗어나고 s도 그렇게 됩니다. 그러나 s의 값이 이동되었으므로
// 별다른 일이 발생하지 않습니다.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어옵니다
    println!("{}", some_string);
} // 여기서 some_string이 스코프 밖으로 벗어나고 `drop`이 호출됩니다.
// 메모리가 해제됩니다.

fn makes_copy(some_integer: i32) { // some_integer가 스코프 안으로 들어옵니다
    println!("{}", some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어납니다. 별다른 일이 발생하지 않습니다.
```
- 대입연산과 함수로 값을 전달할 때 이동(move)이 발생하였는가? 복사(copy)가 발생하였는가가 중요
  - 왜냐하면 이동(move)시 변수가 유효하지 않게 되기 때문

---

## 반환 값과 스코프

- 값을 반환하는 과정에서도 '소유권'은 이동한
```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership이 자신의 반환 값을 s1로
                                        // 이동시킵니다

    let s2 = String::from("hello");     // s2가 스코프 안으로 들어옵니다

    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back로 이동되는데,
                                        // 이 함수 또한 자신의 반환 값을 s3로
                                        // 이동시킵니다
} // 여기서 s3가 스코프 밖으로 벗어나면서 버려집니다. s2는 이동되어서 아무 일도
  // 일어나지 않습니다. s1은 스코프 밖으로 벗어나고 버려집니다.

fn gives_ownership() -> String {             // gives_ownership은 자신의 반환 값을
                                             // 자신의 호출자 함수로 이동시킬
                                             // 것입니다

    let some_string = String::from("yours"); // some_string이 스코프 안으로 들어옵니다

    some_string                              // some_string이 반환되고
                                             // 호출자 함수 쪽으로
                                             // 이동합니다
}

// 이 함수는 String을 취하고 같은 것을 반환합니다
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프 안으로
                                                      // 들어옵니다

    a_string  // a_string이 반환되고 호출자 함수 쪽으로 이동합니다
}
```
- 함수에 넘겨준(이동) 값을 함수 호출 이후에도 쓰고 싶다면 어떻게 하면 좋을까?
  - 함수가 값을 사용할 수 있도록 하되 소유권은 가져가지(이동) 않도록 할 수 없을까?
  - 참조자(reference): 소유권 이동 없이 값을 사용할 수 있는 기능

---

## 참조와 대여

- 참조자(reference)는 해당 주소에 저장된 데이터에 접근할 수 있도록 해주는 주솟값
  - 참조자는 살아있는 동안 특정 타입에 대한 유효한 값을 가리키는걸 보장
  - 데이터(값)은 참조자가 아닌 다른 어떤 변수가 소유하고 있다
- 소유권(move)가 아닌 참조자를 넘겨주는 방법
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```
- `&`기호가 참조자를 나타낸다
- `&s1` 문은 참조자를 생성한다. `s1` 값을 **참조하고** 해당 값을 **소유하지 않는다.**
- 소유권이 없으므로 스코프를 벗어나더라도 참조자가 가리킨 값이 버려지지 않는다
- 참조자를 만드는 행위를 대여(borrow)라고 한다
- 참조자는 기본적으로 참조하는 것을 수정할 수 없다

---

## 가변 참조자(mutable reference)

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
- 가변 참조자는 참조하는 것을 수정할 수 있다
- 제약사항
  - 어떤 값에 가변 참조자가 유효한 동안 그 값에 대한 (불변||가변) 참조자는 더이상 만들 수 없다
  - 위와 같은 동시에 여러 가변 참조자의 사용을 막는건 값의 변경에 대한 제어가 원활하도록 도운다
    - 데이터 경합을 방지 
  - 데이터를 읽기만 하는건 괜찮으므로 여러 개의 불변 참조자를 만드는 건 가능
- 참조자의 유효공간
  - 참조자는 정의된 지점부터 시작하여 해당 참조자가 마지막으로 사용된 부분까지 유효
```rust
    let mut s = String::from("hello");
  
  let r1 = &s; // 문제없음
  let r2 = &s; // 문제없음
  println!("{} and {}", r1, r2);
  // 이 지점 이후로 변수 r1과 r2는 사용되지 않습니다

  let r3 = &mut s; // 문제없음
  println!("{}", r3);
```

---

## 댕글링 참조(dangling pointer)

- 댕글링 참조란?
  - 포인터가 가리키는 메모리를 해제한 메모리를 참조하는 포인터
- 러스트에서는 컴파일러가 참조자가 스코프를 벗어나기 전에 데이터가 먼저 스코프를 벗어나는지를 확인하여 댕글링 참조를 방지
```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

---

## 슬라이스

- 슬라이스는 컬렉션을 통째가 아닌 일부분을 참조하도록 해줍니다
  - use case) 문자열의 일부분을 반환해주고 싶다면?
- 슬라이스는 참조자의 일종으로서 소유권을 갖지 않습니다

---

## 문자열 슬라이스

- 문자열 슬라이스는 `String`의 일부를 가리키는 참조자
- 문자열 슬라이스를 나타내는 타입 `&str`
```rust
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
```
- `[starting_index..ending_index]`
- 슬라이스는 내부적으로 시작위치(포인터), 길이, 용량을 저장한다
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```
- 슬라이스는 참조자의 일종
  - 참조자를 나타내는 표기법 `&`에 `[start..end]`라는 범위 표현법이 결합된 형태
  - 문자열 참조자는 값을 소유하는 변수를 참조하지만, 문자열 슬라이스는 문자열과 같이 데이터를 참조한다는게 특이사항
  - 결론적으로 참조를 하기 때문에 데이터의 변동에 연속적이다
```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // 에러!

    println!("the first word is: {}", word);
}
```
- `clear` 함수는 가변 참조자를 필요로 한다

---

## 슬라이스로써의 문자열 리터럴

- 문자열 리터럴은 바이너리 내에 저장된다
```rust
let s = "Hello, world!";
```
- `s`는 바이너리의 특정 지점을 가리키는 슬라이스(`&str` 타입)
  - `&str`은 불변 참조자

---

## 문자열 슬라이스를 매개변수로 사용하기
```rust
fn first_word(s: &String) -> &str { // 매개변수 s에 &String 가능, &str 불가능
```
```rust
fn first_word(s: &str) -> &str { // 매개변수 s에 &String 가능, &str 가능
```
- 이는 역참조 강제변환(deref coercions)기능















