# 자바 ORM 표준 JPA 프로그래밍 - 10. JPQL

## JPQL

- JPA는 JPQL을 분석한 다음 적절한 SQL를 만들어 데이터베이스를 조회한다  
  그리고 조회한 결과로 엔티티 객체를 생성해서 반환

## JPQL의 특징

- 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리
- SQL를 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다

## 메타모델

- 자바가 제공하는 어노테이션 프로세서 기능을 사용하면 어노테이션을 분석해서 클래스를 생성할 수 있다

## 네이티브 SQL

- 특정 데이터베이스에 의존해야하는 기능을 사용해야할 때 네이티브 SQL을 사용한다
  - 이러한 기능들은 표준화되지 않았기에 JPQL에서 사용할 수 없다

## JPQL 기본문법

- 대소문자 구분: 엔티티와 속성은 대소문자를 구분한다
- 별칭은 필수
- JPQL에서 사용하는 `{entity's name}`는 클래스 명이 아니라 엔티티 명이다

## TypeQuery, Query

- 작성한 JPQL을 실행하려면 **쿼리 객체**를 만들어야한다
- 쿼리 객체는 `TypeQuery`와 `Query`가 있다
  - 반환할 타입을 명확하게 지정할 수 있으면 `TypeQuery`,  
    반환타입을 명확하게 지정할 수 없으면 `Query` 객체
    (e.g. 여러 엔티티나 칼럼을 선택할 때는 반환타입이 명확하지 않으므로 `Query` 객체 사용)
- `Query` 객체는 SELECT 절의 조회대상이 예제처럼 둘 이상이면 `Object[]`를 반환하고 조회대상이 하나면 `Object`를 반환

## 결과조회

- 다음 메소드들을 호출하면 실제 쿼리를 실행해서 데이터베이스를 조회한다
  - `query.getResultList()`: 결과를 반환한다. 결과가 없으면 빈 컬렉션을 반환한다
  - `query.getSingleResult()`: 결과가 정확히 하나일 때 사용
    - 결과가 없으면 `javax.persistence.NoResultException`
    - 결과가 1개보다 많으면 `javax.persistence.NonUniqueResultException`

## 파라미터 바인딩

- 이름기준 파라미터: 이름기준 파라미터는 앞에 `:`를 사용

```java
List<Member> members =
    em.createQuery("SELECT m FROM Member m where m.username = :username", Member.class)
        .setParameter("username", usernameParam)
        .getResultList();
```

## 프로젝션

- 프로젝션: SELECT 절에 조회할 대상을 지정하는 것
  - 프로젝션 대상은 엔티티, 엠비디드 타입, 스칼라타입(기본데이터타입)이 있다
- `[SELECT {프로젝션 대상} FROM]`으로 대상을 선택한다

### 엔티티 프로젝션

- 조회한 엔티티는 영속성 컨텍스트에서 관리한다

```java
SELECT m FROM Member m
SELECT m.team FROM Member m
```

### 임베디드 타입 프로젝션

- 임베디드 타입은 조회의 시작점이 될 수 없다
- 임베디드 타입은 엔티티 타입이 아닌 값타입이다
  - 따라서 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다

```java
String query = "SELECT o.address FROM Order o";
List<Address> addresses = em.createQuery(query, Address.class)
                            .getResultList();
```

### 스칼라 타입 프로젝션

```java
List<String> usernames =
    em.createQuery("SELECT username FROM Member m", String.class)
        .getResultList();
```

### 여러 값 조회

- 프로젝션에 여러 값을 선택하면 `TypeQuery` 대신 `Query`를 사용해야한다

```java
List<Object[]> resultList =
    em.createQuery("SELECT o.member, o.product, o.orderAmount, FROM Order o")
        .getResultList();

for (Object[] row : resultList) {
    Member member = (Member) row[0];        // 엔티티
    Product product = (Product) row[1];     // 엔티티
    int orderAmount = (Integer) row[2];     // 스칼라
}
```

### NEW 명령어

```java
TypedQuery<UserDTO> query =
    em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username, m.age)
    FROM Member m", UserDTO.class);)

List<UserDTO> resultList = query.getResultList();
```

1. 패키지 명을 포함한 전체 클래스 명을 입력해야한다
2. **순서**와 타입이 일치하는 생성자가 필요하다

## 페이징 API

- JPA의 페이징 API
  - `setFirstResult(int startPosition)`: 조회 시작 위치(0부터 시작)
  - `setMaxResults(int maxResult)`: 조회할 데이터 수

```java
TypedQuery<Member> query =
    em.createQuery("SELECT m FROM Member m ORDER BY m.username DESC",
    Member.class);

query.setFirstResult(10);
query.setMaxResults(20);
query.getResultList();
```

## 집합과 정렬

- 집합은 집합함수와 함께 통계 정보를 구할 때 사용

### 집합 함수

- COUNT: 결과 수, 반환타입: Long
- MAX, MIN: 최대, 최소 값. 문자, 숫자, 날짜 등에 사용
- AVG: 평균값, 숫자타입만 가능, 반환타입: Double
- SUM: 합, 숫자타입만 가능, 반환타입: Long, Double, BigInteger, BigDecimal

## JPQL 내부조인

```java
String query = "SELECT m FROM Member m INNER JOIN m.team t "
                + "WHERE t.name = :teamName";
```

- JPQL 조인은 **연관필드**를 사용한다
  - 연관필드란 다른 엔티티와 연관관계를 가지기 위해 사용하는 필드

## 컬렉션 조인

- 일대다 관계나 다대다 관계처럼 컬렉션을 사용하는 곳에 조인하는 걸 컬렉션조인이라 한다
  - 다대일 조인[회원 -> 팀]: 단일 값 연관필드 사용
  - 일대다 조인[팀 -> 회원]: 컬렉션 값 연관필드 사용

## 세타조인

- 세타 조인은 내부 조인만 지원한다

```java
// JPQL
select count(m) from Member m, Team t
where m.username = t.name

// SQL
SELECT COUNT(M.ID)
FROM
    MEMBER M CROSS JOIN TEAM T
WHERE
    M.USERNAME = T.NAME
```

## 페치조인

- 페치 조인은 SQL 조인 종류가 아니고 JPQL에서 성능 최적화를 위해 제공하는 기능
  - `join fetch`: 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능

## 엔티티 페치 조인

- 다음 예시에서 회원 엔티티를 조회하면서 연관된 팀 엔티티도 함께 조회
- 페치 조인은 별칭을 사용할 수 없다

```java
// JPQL
select m
from Member m join fetch m.team

// SQL
SELECT
    M.*, T.*
FROM MEMBER M
INNER JOIN TEAM T ON M.TEAM_ID = T.ID
```

- JPQL 에서 `select m`으로 회원 엔티티만 조회했지만  
  실행된 SQL을 보면(`SELECT M.*, T.*`)회원과 연관된 팀도 함께 조회하다
