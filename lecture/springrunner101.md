# 스프링러너의 스프링 아카데미: spring을 활용한 유여한 백엔드 개발 트레이닝

## 합성

- 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법
  - 객체는 인터페이스를 사용해 참조하라  
    **인터페이스는 정의된 메시지를 통해서만 재사용이 가능하므로** 구현을 효과적으로 캡슐화 가능하다
  - 즉, 합성은 메시지를 통해 느슨하게 결합되며, 따라서 코드를 재사용하기 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다

## 상속(템플릿 메소드 패턴)의 단점

- 캡슐화를 위반한다
  - 반면 합성에서 인터페이스를 활용하면 정의된 메시지를 통해서만 재사용이 가능하므로 캡슐화가 가능하다
  - <https://unluckyjung.github.io/oop/2021/03/17/Inheritance-and-Encapsulation/>
- 설계를 유연하지 못하게 만든다
  - 반면 합성에서는 갈아끼우기가 비교적 더 쉽다

## 팩토리

- 객체를 생성하고 관계를 구성하는 것 또한 하나의 관심사이기 때문에 분리할 필요가 있다
- 이러한 객체 생성방법을 결정하고 생성한 객체를 반환하는 역할을 수행하는 객체를 Factory 라고 부른다

## 제어의 역전

- 프로그램의 제어흐름의 구조가 뒤바뀌는 것
- 모든 객체가 능동적으로 자신이 사용할 객체를 결정하고, 언제 어떻게 그 객체를 만들지를 스스로 관장한다.
  즉 모든 종류의 흐름을 **사용하는 쪽**에서 제어하는 구조다
- 제어 역전원리가 적용된 코드는 자신이 **사용할 객체**를 스스로 결정하지 않는다.
- 자바 프로그램의 흐름은 메인 메소드와 같이 프로그램이 시작되는 지점에서 사용할 객체를 결정하고 결정한 객체를 생성하고, 생성된 객체에 있는 메소드를 호출한다. 다시 호출된 객체 메소드 안에서 또다시 사용할 객체를 결정,생성,호출을 반복
  - 즉, 각 객체는 프로그램 흐름을 결정하거나 사용할 객체를 구성하는 작업에 능동적으로 참여한다.

## SOLID 원칙

- SOLID는 깔끔한 설계를 위해 적용 가능한 다섯가지 소프트웨어 설계 원칙이다
- 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법으로 구성되어 있다
- 모듈과 컴포넌트 내부의 구조를 이해하기 쉽고, 변경에 유연하게 만드는데 목적을 두고 있다

## 개방폐쇄원칙

- 소프트웨어 개체(클래스나 모듈)은 확장에는 열려 있어야하고 변경에는 닫혀 있어야한다.

![Alt text](images/image-56.png)

- `MovieFinder` 변경은 내부 다른 코드를 **변경**하지 않고 `MovieReader`를 갈아끼울 수 있다(**확장**)

## 의존성 역전원칙

- 상위 정책은 하위 정책에 의존하면 안된다. 하위 정책이 상위 정책에 정의된 추상 타입에 의존해야 한다.
- 이전에는 `MovieFinder`가 직접 `CsvMovieReader`를 의존하고 있었다. 이는 상위 정책인 `MovieFinder`가 하위 정책인 `CsvMovieReader`에 의존하고 있는 것
  - 이런 환경에서는 추상화된 `MovieReader`의 다형성이 동작하기 어렵다 -> `MovieFinder`가 직접 구체적인 하위객체를 생성하므로 다른 구현체를 사용할 수 없다
- 개선 후에는 런타임의 생성자를 통해 객체를 주입받아 사용하므로 다형성을 적극 활용 가능하고 재사용성이 높아진다

## 관심사의 분리

- 관심이 같은 것끼리는 한 곳으로(객체) 모으고, 다른 것은 따로 떨어뜨려 서로 영향을 주지 않도록 분리하는 것
  - 관심사가 같은 코드를 모아 **응집**시키고,
    관심사가 다른 코드는 분리하고 서로 낮은 **결합**을 갖도록 한다.

## 높은 응집도

- 응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중이 되어 있다는 뜻입니다
- 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀있지않고 하나의 공통 관심사는 하나의 클래스에 모여 있다.

## 낮은 결합도

- 결합도가 낮다는 건 하나의 클래스가 변경이 일어날 때 관계를 맺고 있는 다른 클래스에 영향을 주지 않는다는 뜻
- 책임과 관심사가 다른 클래스 또는 모듈과는 낮은 결합도(**느슨한 연결형태**)를 유지하는게 좋다
  - 느슨한 연결은 관계를 유지하는 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고 나머지는 서로 독립적이고 알 필요없게 만들어주는 것
- 결합도가 낮아지면 변화에 대응하는 속도가 높아지고 구성이 깔끔해집니다. 또한 확장하기에도 편리하다

## 디자인 패턴

- 소프트웨어 설계시 자주 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결방법

## 전략 패턴

![Alt text](images/image-57.png)

- 전략 패턴은 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 추상화를 통해 통째로 외부로 분리시키고 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔 사용할 수 있게 하는 디자인패턴
- `MovieFinder`는 전략 패턴의 콘텍스트에 해당한다
  - 콘텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한 알고리즘(메타데이터 읽기 알고리즘)을 `MovieReader`라는 인터페이스로 추상화하고 이를 구현한 클래스(전략)을 바꿔가면서 사용할 수 있게 하는 것

## 템플릿 메소드 패턴

- 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해서 전체 구조는 바꾸지 않으면서도 특정 행위를 수행하는 전략만 바꾸는 패턴
  ![Alt text](images/image-58.png)

## 의존관계(dependency)

![Alt text](images/image-59.png)

- 의존관계 정의: 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메소드를 호출하는 경우, 두 클래스 사이에 의존관계가 있다고 말한다.
  - 의존관계가 형성되면 `MovieReader`의 기능이 추가되거나 변경되었을 때 그 영향이 `MovieFinder`에게 전달된다
  - 의존관계는 객체와 객체가 협력하기 위해서는 반드시 필요하다
- **객체지향설계 핵심**은 협력을 위해 필요한 의존관계는 유지하면서도 변경을 방해하는 의존 관계는 제거하는데 있다
  - 객체지향설계란 의존관계를 관리하는 것이고 객체가 변경을 받아들일 수 있게 의존관계를 정리하는 기술

## 의존관계주입(Dependency Injection, DI)

- 코드 시점의 의존관계와 실행시점의 의존관계가 서로 다를 수 있다(다시말해 클래스 사이의 의존관계와 객체(인스턴스) 사이의 의존관계는 동일하지 않을 수 있다)
  - e.g. 코드상에서 `MovieFinder`클래스는 `MovieReader` 인터페이스에게 메시지를 전송하지만 실행시점에 실행되는 메소드는 협력하는 객체의 실제 클래스가 무엇인지에 따라 다르다(메세지를 수신하는 클래스에 따라 달라진다)
- **정의**:외부의 독립적인 존재가 객체를 생성한 후 이를 전달해서 의존관계를 해결하는 방법
- 방법: 생성자주입(생성하는 시점), 설정자주입(생성 후), 메서드 주입(메서드 실행시)

## 다형성

![Alt text](images/image-60.png)
![Alt text](images/image-61.png)

- 의존관계주입은 객체 지향 프로그램의 코드시점 의존관계와 실행시점 의존관계가 다를 수 있다는 사실에 기반으로 한다

## 스프링 IoC 컨테이너

![Alt text](images/image-62.png)

- 스프링은 제어의 역전 원칙에 따라 객체의 생성, 의존관계주입과 가능 기능을 제공하는 IoC 컨테이너로 빈 팩토리를 제공한다
- 애플리케이션 콘텍스트는 빈 팩토리 특징을 그대로 가지고 있으면서 스프링 AOP 통합, 국제화지원, 이벤트기반애플리케이션, 웹애플리케이션을 위한 기능을 제공한다
- 빈팩토리(애플리케이션 콘텍스트)는 컨피규레이션 메타데이터라는 빈 구성 정보를 읽어 빈을 생성하고 관리한다

![Alt text](images/image-63.png)

## 빈

- 스프링 빈은 스프링 컨테이너가 생성, 관계설정, 사용 등을 제어해주는 제어의 역전 원리가 적용된 객체
  - 객체 단위의 애플리케이션 컴포넌트를 말한다
- 다시말해, 컨테이너에 의해 생성 및 조립된 후 관리(초기화 소멸 등)되는 객체를 빈이라 부른다

## 정리:스프링 IoC 컨테이너와 빈

- 스프링은 IoC 컨테이너인 애플리케이션 콘텍스트나 빈 팩토리로 빈 구성 정보를 읽어 애플리케이션을 구성합니다
- 스프링 애플리케이션은 객체의 생성과 의존관계설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 독립적인 컨테이너가 담당한다.
  - 즉, 컨테이너가 코드 대신 객체에 대한 제어권을 가지고 있으므로 IoC라고 부른다.
- 컨테이너는 제어의 역전원리가 적용된 스프링 핵심 컴포넌트
- 빈 생성시 의존관계주입이 일어난다
- 빈 구성정보를 바탕으로 비즈니스 오브젝트를 이용해 애플리케이션을 구성하고 생애를 관리한다.

## 빈 구성정보(Configuration Metadata)

- 스프링 컨테이너가 빈 객체 생성 및 구성, 조립시 사용하는 설정정보
- 컨테이너 기능을 설정하거나 조정이 필요할 때도 사용
- 스프링은 빈 구성정보를 읽고 `Bean Definition`이라는 인터페이스로 추상화된 객체를 만들어 사용
  - IoC 컨테이너는 `Bean Definition`으로 만들어지는 객체를 사용해 애플리케이션을 구성합니다 -> 특정 파일포맷이나 형식에 제한되거나 종속되지 않는다
- 자바 코드로 작성하는 빈 구성정보는 관심사가 같은 컴포넌트들을 함께 묶어 모듈화가 가능하다 -> 여러 개의 구성정보를 작성하고 조합할 수 있다

## 빈 스코프

- 스프링 컨테이너는 빈을 생성할 때 단 하나의 빈을 만들지,
  아니면 빈이 요청될 때마다 새로운 빈 객체를 만들지 결정하는 메커니즘
- 싱글톤 스코프: 단 하나의 빈 객체만 만들 때  
  프로토타입 스코프: 빈이 요청될 때마다 새로운 빈을 생성하기

## 싱글톤 스코프

- 스프링 컨테이너 내에서 단 하나만 생성이 되고, 그 빈을 의존하는 모든 빈에 유일한 객체를 공유한다.

## @Import, @ImportResource

- `@Import` 애노테이션은 다른 클래스에서 빈 구성 정보를 불러오기 위해 사용한다
- XML 형식으로 작성된 빈 구성정보가 있다면 `@ImportResource`으로 XML 파일 위치를 지정해주면 된다

## @ComponentScan

- `@ComponentScan`으로 자동 클래스 탐지 기능을 활성화하면 지정된 패키지 경로에서 스테레오타입(e.g. `@Component`)으로 선언된 클래스를 찾아 빈으로 등록하고 관리한다
  - 패키지를 지정하지 않으면 ComponentScan 애노테이션이 선언된 클래스를 기준으로 탐색한다

## Stereotype Bean

- 각 스테레오 타입 애노테이션은 빈의 역할과 관련이 있다
- `@Service`는 다른 빈이 필요로 하는 서비스를 제공하는 복잡한 비즈니스 기능을 가진 빈을 정의하는데 사용
- `@Repository`는 데이터베이스와 같이 데이터 접근 기술이 사용되는 빈을 정의하는데 사용

## 자동 와이어링(Autowired)

- 스프링은 빈이 생성된 후 자동으로 의존관계를 주입해주는 기법
- 생성자가 **하나** 뿐이라면 `@Autowired` 생략가능
  - 두개 이상의 생성자일 경우에는 스프링이 어떤 생성자로 생성해야할지 모르기 때문에 문제가 발생한다
- 처음은 타입을 기반으로(선언되어 있는 타입) 해당하는 빈을 찾아 의존관계주입을 해결하고,  
  만약 같은 타입의 빈이 2개 이상 존재하면 (설정된 빈의)이름으로 의존관계를 구성해주는 전략을 가진다
- ComponentScan을 통해서 자동으로 빈이 등록이 될 때는 클래스의 이름을 기반으로 빈의 이름이 등록된다

## 테스트 컨텍스트 프레임워크

![Alt text](images/image-64.png)

- 스프링은 테스트에 사용되는 스프링 컨테이너를 생성 및 관리하고 테스트에 적용할 수 있는 기능을 가진 테스트 프레임워크를 제공한다
- 테스트 컨텍스트 프레임워크는 JUnit 또는 TestNG와 같은 테스트 프레임워크와 잘 통합되어 동작한다

## `@ExtendWith`, `SpringExtension.class`

- `@ExtendWith`: JUnit 이 테스트 실행 전략을 확장할 때 사용하는 애노테이션
- `SpringExtension.class`: 스프링의 테스트 컨텍스트 프레임워크에서 제공하는 JUnit 지원클래스로,  
  JUnit이 테스트를 실행하는 과정에서 테스트가 필요로 하는 스프링 컨테이너를 구성하고 관리해줍니다
  - 스프링 컨테이너를 구성할 때 `@ContextConfiguration` 어노테이션이 지정이 되어있다면 해당 어노테이션이 저장한 빈 구성정보를 바탕으로 스프링 컨테이너를 만든다
