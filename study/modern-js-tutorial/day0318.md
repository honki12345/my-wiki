# 모던 JavaScript 듀토리얼 day03

- 읽을파트: [파트 1 9.2] 클래스 상속
- 평가: 유익, `[[HomeObject]]`가 잘 이해되지 않으나 그래도 클래스에 대해 깊게 배울 수 있었다

---

## [파트 1 9.2] 클래스 상속

- `extends`
  - 키워드 `extends`는 프로토타입 기반으로 동작합니다. `extends`는 `Rabbit.prototype.[[Prototype]]`을 `Animal.prototype` 으로 설정합니다
- `extends` 뒤에 표현식이 올 수도 있습니다
  - `extends` 뒤에서 부모 클래스를 만들어주는 함수를 호출할 수 있죠
- `super`
  - `super.method(...)`는 부모클래스에 정의된 메서드, `method`를 호출합니다
  - `super(...)`는 부모 생성자를 호출하는데, 자식 생성자 내부에서만 사용할 수 있습니다
  - 화살표 함수는 `super`를 지원하지 않습니다
    - `super`에 접근하면 `super`를 외부 함수에서 가져옵니다
- 생성자 오버라이딩
  - 명세서에 따르면 클래스가 다른 클래스를 상속받고 `constructor`가 없는 경우엔 '비어있는' `constructor`가 만들어집니다
  - 비어있는 생성자는 기본적으로 부모 `constructor`를 호출합니다. 이때 부모 `constructor`에도 인수를 모두 전달합니다
  - 자바스크립트는 '상속 클래스의 생성자함수(derived constructor)와 그렇지 않은 생성자 함수를 구분합니다
    - 상속 클래스의 생성자 함수엔 특수 내부 프로퍼티인 `[[ConstructorKind]]: "derived"`가 이름표처럼 붙습니다
    - 일반클래스가 `new`와 함께 실행되면 빈 객체가 만들어지고 `this`에 객체를 할당합니다
    - 상속클래스의 생성자 함수가 실행되면 *부모클래스의 생성자*가 빈 객체를 만들고 `this`에 이 객체를 할당해주어야합니다
      - 그렇기 때문에 상속 클래스의 생성자에서 `super`를 호출해 부모 생성자를 실행해주어야 합니다. 그렇지 않으면 `this`가 될 객체가 만들어지지 않아 에러가 발생합니다
- 부모 생성자는 자식 클래스에서 오버라이딩한 값이 아닌, 부모 클래스 안의 필드 값을 사용합니다
- 필드 초기화 순서
  - 상속 없는 베이스클래스는 생성자 실행 이전에 초기화됨
  - 부코 클래스가 있는 경우엔 `super()` 실행 직후에 초기화됨
- super 키워드와 `[[HomeObject]]`
  - 함수 전용 특수내부 프로퍼티
  - 클래스/객체 메서드인 함수의 `[[HomeObject]]` 프로퍼티는 해당 객체가 저장됩니다
    - `[[HomeObject]]`는 메서드가 객체를 기억하게 만들어준다
  - `super`는 `[[HomeObject]]`를 이용해 부모 프로토타입과 메서드를 찾습니다
