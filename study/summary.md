# 1주차

- 1 ~ 5장

## 리눅스 프로그래밍

- 리눅스 프로그래밍이란?
  - 리눅스에서 돌아가는 프로그램을 만들기
  - 그러기 위해서 리눅스가 내부적으로 어덯게 구성되고 동작하는지 이해해보자

## 리눅스를 이해하기 위한 세가지 개념

- 파일 시스템
  - 데이터에 이름을 붙여 보관ㅎ고 관리하는 시스템
- 프로세스
  - 어떤 활동을 하는 주체
- 스트림
  - 다른 프로세스와 데이터를 주고 받는 수단

## 세그먼테이션 폴트

- 널 포인터를 참조하거나 배열의 범위를 넘어서서 접근하거나 하면 세그먼테이션 폴트라고 하는 에러 이름으로 강제 종료됨
  - 세그먼테이션(segmentation)이란 용어가 의미하는 바가 있을뜻. 운영체제단? c언어 프로그래밍언어 단?

## glob패턴

```sh
$ ./args *.c
argc = 3
argv[0] = ./args
argv[1] = hello.c
argv[2] = bye.c
```

- `*`, `?` 같은 와일드카드(glob패턴)을 사용하여 **파일 이름의 집합**을 표현할 수 있다
  이러한 파일 이름의 집합은 셸에 의해 개별 인자로 변경됨

## 리눅스 기본 용어

- 커널: 보통 하나의 프로그램으로 구성되어 컴퓨터를 구성하는 모든 하드웨어와 소프트웨어를 관리
- 리눅스 운영체제: 커널뿐만 아니라 다른 소프트웨어를 포함
- 리눅스: 커널
- 디바이스: CPU, 메모리 같은 물리적인 부품(하드웨어)
- 디바이스 드라이버: 특정 디바이스를 조작하는 소프트웨어
- 시스템 콜: 일반 프로그램이 커널에디바이스 조작 작업을 의뢰하기 위해 사용하는 것
  - 여기서 시스템은 커널을 말하고, 커널을 호출(call) 하므로 시스템 콜이라 한다
- 링크: 함수를 빌리는 작업. 함수를 링크해두면 해당 함수를 호출하는 것이 가능하다
- 파일시스템: 파일을 다루는 시스템
- 마운트: 디스크(물리적인 기억장치)를 파티션 단위로 나눠 그 위에 파일 시스템을 **얹는다**(mount)
- 프로세스: 실행 중인 프로그램
- 프로그램: 파일 형태로 존재하는 실행 가능한 파일
- 프로세스 ID: 시스템에서 돌고 있는 모든 프로세스 간에 중복되지 않도록 프로세스에 할당된 번호
- 스트림: 바이트의 흐름, 바이트들이 흘러 다니는 길(통로)
  - 다른 책에서는 파일이나 open file로 다뤄진다
  - 다른 책에서는 스트림이란 단어를 다음 두가지로 사용
    - FILE(스트림을 다룰 때 사용하는 자료구조), STREAMS( 스트림 기능을 위해 사용되는 커널 모듈)
- 읽기/쓰기
  - 읽기: 스트림에서 바이트 열을 꺼내는 것
  - 쓰기: 스트림에서 바이트 열을 흘려보내는 것
- 파이프: 스트림의 양 끝에 프로세스가 있는 구조
- 프로세스 간 통신: 프로세스 간에 스트림을 통해 데이터를 주고 받으며 의사소통을 하는 것
- 다중 사용자 시스템: 여러 명의 사용자가 동시에 사용할 수 있는 시스템
  - 로그인과 권한 관리 기능 발달

## 파일의 종류

- 보통 파일(regular file)
  - 데이터가 들어 있는 파일
- 디렉터리
  - 다른 파일들을 담아 둘 수 있는 파일
- 심볼릭 링크 
  - 다른 파일을 가리키는 파일
  - 심볼릭 링크 파일을 열면 커널이 자동으로 연결된 파일을 열어준다.
  - 즉, 심볼릭 링크를 사용하면 파일이나 디렉터리에 다른 이름, 별명을 부여할 수 있다
- 디바이스 파일
  - 디바이스(하드웨어)를 파일로 표현한 것
  - 하드웨어에 따라 문자 디바이스 파일과 블록 디바이스 파일로 나눌 수 있다
    - 차이점은 원하는 시점에 원하는 곳에 접근할 수 있는가이다
- 명명된 파이프(named pipe)
  - 프로세스 간 통신에 사용하는 파일

## 자격증명

- 프로세스가 가지는 사용자의 속성
- 이 프로세스는 리눅스 상에서 이 사용자의 대리인으로 동작하고 있다는 증명서
- 로그인을 하는 과정에서 사용자의 증명서를 가진 프로세스가 시스템에 생성됨
- 이 최초의 프로세스가 다른 명령(프로세스를 실행할 때 증명서를 자동으로 복사하고 전달함

## 사용자 이름과 사용자 ID

- 리눅스 커널은 사용자이름이 아닌 사용자 ID를 기반으로 동작함
  - 프로세스의 자격증명, 파일의 소유자도 모두 ID로 기록
- 사용자 이름과 사용자 ID의 매핑은 일반적으로 `/etc/passwd`에 기록되어있음

## 단말(terminal)

- 단말은 컴퓨터 하드웨어 중에서 사용자가 (컴퓨터와) 직접 접촉하는 부분
- 단말 에뮬레이터: 하드웨어 였던 단말을 전부 소프트웨어로 구현한 것
- 가상콘솔: 소프트웨어적으로 만든 단말

## 파일 디스크립터

- 파일디스크립터: 커널이 스트림을 열 때 부여하는 번호
- 표준 입력, 표준 출력, 표준 에러 출력
  - 셸을 통해 프로세스가 생성되는 경우 위의 세 개의 스트림이 기본적으로 생성됨
  - 이들 스트림은 각각 파일디스크립터 0, 1, 2에 할당
  - 여기서 표준이란 말은 디폴트로 이해하면 됨

## read(2)

- 데이터의 끝에 `\0`이 있다고 전제하지 않는 API.
- 즉, `printf()`같이 문자열의 끝에 `\0`이 들어있다고 전제하는 API에 `read()`로 읽어들인 문자열을 그대로 전달해서는 안됨

## close()

- 프로세스가 종료되면 사용하던 모든 스트림을 커널이 파기하기 때문에 `close()`를 하지 않아도 시스템에 이상이 가지 않음
- 하지만 프로세스가 실행중일 때는 동시에 사용할 수 있는 스트림의 개수에 제한도 있고,
- 스트림 반대편이 `close()`할 때까지 기다릴 수도 있음

## errno

- 일반적으로 시스템 콜이 실패할 경우 그 원인을 나타내는 정수가 전역변수 errno에 설정됨

## 파일 오프셋

- 스트림은 마지막으로 읽은 파일의 위치를 기억하고 있음
- 이렇게 스트림이 연결되어 있는 위치를 파일오프셋이라고 한다
- 파일 오프셋은 시스템콜 `lseek()`로 조작 가능
  - `lseek()`은 파일 디스크립터 내부의 파일 오프셋을 지정한 위치로 이동
