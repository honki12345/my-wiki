# Real MySQL 9.3 고급최적화

## 9.3 고급 최적화

- 옵티마이저가 실행 계획을 수립할 때는 통계정보와 옵티마이저 옵션을 결합해서 최적의 실행계획을 수립한다
- 옵티마이저 옵션은 (1. 조인 관련된 옵티마이저 옵션)과 (2. 옵티마이저 스위치)로 구분할 수 있다

### 9.3.1 옵티마이저 스위치 옵션

- 옵티마이저 스위치 옵션은 `optimizer_switch`시스템 변수를 이용해 제어한다
- `optimizer_switch` 시스템 변수에는 여러 개의 옵션을 세트로 묶어 설정하는 방식을 사용한다
- 각각의 옵티마이저 스위치 옵션은 "default"(기본값), "on", "off" 중에서 하나를 설정한다
- 옵티마이저 스위치 옵션은 글로벌과(서버 전체적으로), 세션별(현재 커넥션에만), 또는 현재 쿼리에만 설정가능하다

### 네스티드 루프 조인(Nested Loop Join)

- 드라이빙 테이블의 레코드를 한 건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아 조인을 수행하는 것
- 레코드를 읽어 다른 버퍼 공간에 저장하지 않고 즉시 드리븐 테이블의 레코드를 찾아 반환한다

### 9.3.1.1 MRR과 배치 키 액세스(mrr & batched_key_access)

- MRR(Multi-Range Read)란 조인 대상 테이블 중 하나로부터 레코드를 읽어서 조인버퍼에 버퍼링 한다. 조인 버퍼에 레코드가 가득 차면 비로소 MySQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청한다
  - 이렇게하면 스토리지 엔진은 읽어야할 레코드들을 데이터 페이지에 정렬된 순서로 접근해서 디스크의 데이터 페이지 읽기를 최소화할 수 있다 (?)
- MKA(Batched Key Access)조인이란 MRR을 응용해서 실행되는 조인방식
- MKA 조인에는 부가적인 정렬 작업이 필요해지면서 성능에 안 좋은 영향을 미치는 경우도 있다

### 9.3.1.2 블록 네스티드 루프 조인(block_nested_loop)

- 네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 차이는 조인 버퍼가 사용되는지 여부와 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되느냐다
- 조인 쿼리의 실행계획에서 `Extra`칼럼에 "Using Join buffer"가 표시되면 그 실행계획은 조인 버퍼를 사용한다는 의미이다
- 조인버퍼란 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 **드라이빙 테이블에서 읽은 레코드를 캐시**한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리한다. 이 때 사용되는 메모리의 캐시를 조인버퍼라 한다
  - 조인버퍼는 `join_buffer_size`라는 시스템 변수로 크기를 제한할 수 있으며, 조인이 완료되면 조인 버퍼는 바로 해제된다
- 조인버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인것처럼 실행된다
  - 드라이빙 테이블의 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리되기 때문이다
  - 그러므로 드라이빙 테이블의 순서에 의해 결정되는 일반적인 조인방식과 달리 조인버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있다
- MySQL 8.0.18버전부터는 해시 조인 알고리즘이 도입됐고 8.0.20버전부터는 블록 네스티드 루프 조인은 더이상 사용되지 않고 해시 조인 알고리즘이 대체되어 사용된다

### 9.3.1.3 인덱스 컨디션 푸시다운(index_condition_pushdown)

- MySQL 5.6 버전부터 인덱스를 범위 제한 조건으로 사용하지 못한다고 하더라도 인덱스에 포함된 칼럼의 조건이 있다면 모두 같이 모아서 스토리지 엔진으로 전달할 수 있게 핸들러 API가 개선되었다

### 9.3.1.4 인덱스 확장(use_index_extensions)

- `use_index_extensions` 옵티마이저 옵션은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션
- InnoDB 스토리지 엔진은 프라이머리 키를 클러스터링 키로 생성한다. 그래서 모든 세컨더리 인덱스는 리프 노드에 프라이머리 키 값을 가진다
- 실행계획의 `key_len` 칼럼은 이 쿼리가 인덱스를 구성하는 칼럼 중에서 어느 부분(어느 칼럼)까지 사용했는지를 바이트 수로 보여준다

### 9.3.1.5 인덱스 머지(index_merge)

- 인덱스 머지 실행계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다
  - 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때 MySQL 서버는 인덱스 머지 실행계획을 선택한다
- 인덱스 머지 실행 계획은 다음과 같이 3개의 세부 실행 계획으로 나누어 볼 수 있다
  - index_merge_intersection
  - index_merge_sort_union
  - index_merge_union
- `index_merge`옵티마이저 옵션은 위의 나열된 3개의 최적화 옵션을 한 번에 모두 제어할 수 있는 옵션

### 9.3.1.6 인덱스 머지 - 교집합(index_merge_intersection)

- 실행계획의 `Extra`칼럼에 "Using intersect"라고 표시된 것은 이 쿼리가 여러 개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환했다는 것을 의미한다

### 9.3.1.7 인덱스 머지 - 합집합(index_merge_union)

- 인덱스 머지의 'Using union'은 WHERE 절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 `OR` 연산자로 연결된 경우에 사용하는 최적화다
  - 인덱스 검색 결과를 'Union' 알고리즘으로 병합(두 집합의 합집합을 가져오는 것)한다
- 우선순위 큐를 이용해 중복제거를 한다
  - 두 집합의 결과를 하나씩 가져와 서로 비교하면서 중복 제거를 수행한다

### 9.3.1.8 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)

- 인덱스 머지 작업을 하는 도중에 결과의 정렬이 필요한 경우 MySQL 서버는 인덱스 머지 최적화의 'Sort union' 알고리즘을 사용한다
  - 두 집합의 결과에서 중복을 제거하기 위하여 각 집합을 정렬 한다음 중복제거를 수행한다

### 인덱스 사용과 `OR`연산자, `AND`연산자

- 2개의 조건이 `AND`로 연결된 경우: 두 조건 중 하나라도 인덱스를 사용할 수 있으면 인덱스 레인지 스캔으로 쿼리가 실행된다
- 2개의 조건이 `OR`로 연결된 경우: 둘 중 하나라도 인덱스를 사용할 수 없으면 항상 풀 테이블 스캔으로 처리한다

### 9.3.1.9 세미조인

- 다른 테이블과 실제 조인을 수행하지는 않고, 단지 테이블에서 조건에 일차하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리를 세미조인이라고 한다
- 세미 조인 최적화 전략들
  - Table Pull-out
  - Duplicate Weed-out
  - First Match
  - Loose Scan
  - Materialization

### 9.3.1.10 테이블 풀-아웃(Table Pull-out)

- Table pullout 최적화는 세미조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인쿼리로 재작성하는 형태의 최적화이다
- Table pullout 최적화는 별도로 실행계획에 메세지를 출력하지 않는다
  - 그러므로 실행계획에서 해당 테이블들의 id 칼럼값이 같은지 비교해보는 것, 또한 `Extra`칼럼에 아무것도 출력되지 않았는지를 확인한다

### 9.3.1.11 퍼스트 매치(firstmatch)

- First Match 최적화 전략은 `IN`(subquery) 형태의 세미조인을 `EXISTS`(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실해된다
- First Match는 서브쿼리가 아니라 조인으로 풀어서 실행하면서 일치하는 첫번째 레코드만 검색하는 최적화전략이다

### 9.3.1.12 루스스캔(loosescan)

- LooseScan 최적화는 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고 그다음으로 아우터 테이블을 드리븐으로 사용해서 조인을 수행한다
- 루스 인덱스 스캔 최적화는 다음과 같은 형태의 서브쿼리들에서 사용할 수 있다

  ```sql
  SELECT ... FROM ... WHERE expr IN (SELECT keypart1 FROM tab WHERE ...)
  SELECT ... FROM ... WHERE expr IN (SELECT keypart2 FROM tab WHERE keypart1='상수')
  ```

### 9.3.1.13 구체화(Materialization)

- 구체화 최적화는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미다
- 구체화란 내부 임시 테이블을 생성한다는 것을 의미한다
- Materialization 최적화는 다른 서브쿼리 최적화와는 달리, 서브 쿼리 내에 `GROUP BY`가 있어도 사용가능하다

### 9.3.1.14 중복제거(Duplicated Weed-out)

- Depulicate Weedout은 세미 조인 서브쿼리를 일반적인 `INNER JOIN` 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다
  - 원본 쿼리를 `INNER JOIN + GROUP BY`절로 바꿔서 실행하는 것과 동일한 작업으로 쿼리를 처리한다

### 9.3.1.15 컨디션 팬아웃(condition_fanout_filter)

- MySQL 옵티마이저는 여러 테이블이 조인되는 경우 가능하다면 일치하는 레코드 건수가 적은 순서대로 조인을 실행한다

### 9.3.1.16 파생 테이블 머지(derived_merge)

- `FROM`절에 사용된 서브쿼리를 파생테이블(Derived Table)이라 한다
- 파생 테이블로 만들어지는 서브쿼리를 외부쿼리와 병합해서 서브쿼리를 제거하는 최적화
- 내부적으로 생성되는 임시테이블은 처음에는 메모리에 생성되지만 임시테이블에 저장될 레코드 건수가 많아지면 결국 디스크로 다시 기록돼야 한다.
- 옵티마이저가 자동으로 서브쿼리를 외부쿼리로 병합할 수 없는 조건
  - `SUM()` 또는 `MIN()`, `MAX()`같은 집계함수와 윈도우 함수(Window Function)가 사용된 서브쿼리
  - `DISTINCT`가 사용된 서브쿼리
  - `GROUP BY`나 `HAVING`이 사용된 서브쿼리
  - `LIMIT`이 사용된 서브쿼리
  - `UNION` 또는 `UNION ALL`을 포함하는 서브쿼리
  - `SELECT` 절에 사용된 서브쿼리
  - 값이 변경되는 사용자 변수가 사용된 서브쿼리

### 9.3.1.17 인비저블 인덱스(use_invisible_indexes)

- MySQL 8.0 이전 버전까지는 인덱스가 존재하면 항상 옵티마이저가 실행계획을 수립할 때 해당 인덱스를 검토하고 사용했다
  MySQL 8.0 버전부터는 인덱스를 삭제하지 않고 해당 인덱스를 사용하지 못하게 제어하는 기능을 제공한다

### 9.3.1.18 스킵 스캔(skip_scan)

- 이 최적화는 인덱스의 선행 칼럼이 조건절에 사용되지 않더라도 후행 칼럼의 조건만으로도 인덱스를 이용한 쿼리 성능 개선이 가능하다
- MySQL 8.0 옵티마이저는 인덱스의 선행칼럼이 소수의 유니크한 값을 가질 때만 인덱스 스캡 스캔 최적화를 사용한다
  - 인덱스의 선행 칼럼이 매우 다양한 값을 가지는 경우에는 인덱스 스킵 스캔 최적화가 비효율적일 수 있다

### 9.3.1.19 해시조인(hash_join)

- 네스티드 루프조인과 해시조인의 비교
  - 네스티드 루프조인은 첫번째 레코드를 빠르게, 마지막 레코드는 늦게
  - 해시조인은 첫번째 레코드를 늦게, 마지막 레코드는 빨리
  - 결론: 해시조인 쿼리는 최고 스루픗(Best Throughput) 전략에 적합하고
    네스티드 루프 조인은 최고응답속도(Best Response-time) 전략에 적합하다
- MySQL 서버는 조인 조건 칼럼이 인덱스가 없다거나 조인대상 테이블 중 일부의 레코드 건수가 매우 적은 경우 등에 대해서만 해시 조인 알고리즘을 사용하도록 설계돼 있다
- 해시조인은 빌드단계(build-phase)와 프로브단계(probe-phase)로 나뉜다
  - 빌드단계에서는 1.(조인 대상 테이블 중에서 레코드 건수가 적어서 해시테이블로 만들기에 용이한 테이블을 골라서) 2.(메모리에 해시테이블을 생성(빌드))하는 작업을 수행한다
  - 빌드 단계에서 해시 테이블을 만들 때 사용되는 원본 테이블을 빌드 테이블이라고 한다
  - 프로브 단계에서는 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾는 과정이다
    이때 읽는 나머지 테이블을 프로브 테이블이라 한다
- 메모리의 해시테이블을 준비하다가 지정된 메모리크기를 넘어서면 나머지 레코드를 디스크에 청크로 구분해서 저장한다
  - 뭔말인지 잘모르겠다

### 9.3.1.20 인덱스 정렬 선호(prefer_ordering_index)

- MySQL 옵티마이저는 `ORDER BY` 또는 `GROUP BY`를 인덱스를 사용해 처리 가능한 경우 쿼리의 실행계획에서 이 인덱스의 가중치를 높이 설정해서 실행된다

### 9.3.2.1 Exhaustive 검색 알고리즘

- MySQL 5.0과 그 이전 버전에서 사용되던 조인 최적화 기법으로, `FROM`절에서 명시된 **모든 테이블의 조합**에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법이다

### 9.3.2.2 Greedy 검색 알고리즘

- Exhaustive 검색 알고리즘의 시간 소모적인 문제점을 해결하기 위해 MySQL 5.0부터 도입된 최적화 기법이다
