# Real MySQL 9.3 고급최적화

## 9.3 고급 최적화

- 옵티마이저가 실행 계획을 수립할 때는 통계정보와 옵티마이저 옵션을 결합해서 최적의 실행계획을 수립한다
- 옵티마이저 옵션은 (1. 조인 관련된 옵티마이저 옵션)과 (2. 옵티마이저 스위치)로 구분할 수 있다

### 9.3.1 옵티마이저 스위치 옵션

- 옵티마이저 스위치 옵션은 `optimizer_switch`시스템 변수를 이용해 제어한다
- `optimizer_switch` 시스템 변수에는 여러 개의 옵션을 세트로 묶어 설정하는 방식을 사용한다
- 각각의 옵티마이저 스위치 옵션은 "default"(기본값), "on", "off" 중에서 하나를 설정한다
- 옵티마이저 스위치 옵션은 글로벌과(서버 전체적으로), 세션별(현재 커넥션에만), 또는 현재 쿼리에만 설정가능하다

### 네스티드 루프 조인(Nested Loop Join)

- 드라이빙 테이블의 레코드를 한 건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아 조인을 수행하는 것
- 레코드를 읽어 다른 버퍼 공간에 저장하지 않고 즉시 드리븐 테이블의 레코드를 찾아 반환한다

### 9.3.1.1 MRR과 배치 키 액세스(mrr & batched_key_access)

- MRR(Multi-Range Read)란 조인 대상 테이블 중 하나로부터 레코드를 읽어서 조인버퍼에 버퍼링 한다. 조인 버퍼에 레코드가 가득 차면 비로소 MySQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청한다
  - 이렇게하면 스토리지 엔진은 읽어야할 레코드들을 데이터 페이지에 정렬된 순서로 접근해서 디스크의 데이터 페이지 읽기를 최소화할 수 있다 (?)
- MKA(Batched Key Access)조인이란 MRR을 응용해서 실행되는 조인방식
- MKA 조인에는 부가적인 정렬 작업이 필요해지면서 성능에 안 좋은 영향을 미치는 경우도 있다

### 9.3.1.2 블록 네스티드 루프 조인(block_nested_loop)

- 네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 차이는 조인 버퍼가 사용되는지 여부와 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되느냐다
- 조인 쿼리의 실행계획에서 `Extra`칼럼에 "Using Join buffer"가 표시되면 그 실행계획은 조인 버퍼를 사용한다는 의미이다
- 조인버퍼란 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 **드라이빙 테이블에서 읽은 레코드를 캐시**한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리한다. 이 때 사용되는 메모리의 캐시를 조인버퍼라 한다
  - 조인버퍼는 `join_buffer_size`라는 시스템 변수로 크기를 제한할 수 있으며, 조인이 완료되면 조인 버퍼는 바로 해제된다
- 조인버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인것처럼 실행된다
  - 드라이빙 테이블의 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리되기 때문이다
  - 그러므로 드라이빙 테이블의 순서에 의해 결정되는 일반적인 조인방식과 달리 조인버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있다
- MySQL 8.0.18버전부터는 해시 조인 알고리즘이 도입됐고 8.0.20버전부터는 블록 네스티드 루프 조인은 더이상 사용되지 않고 해시 조인 알고리즘이 대체되어 사용된다

### 9.3.1.3 인덱스 컨디션 푸시다운(index_condition_pushdown)

- MySQL 5.6 버전부터 인덱스를 범위 제한 조건으로 사용하지 못한다고 하더라도 인덱스에 포함된 칼럼의 조건이 있다면 모두 같이 모아서 스토리지 엔진으로 전달할 수 있게 핸들러 API가 개선되었다

### 9.3.1.4 인덱스 확장(use_index_extensions)

- `use_index_extensions` 옵티마이저 옵션은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션
- InnoDB 스토리지 엔진은 프라이머리 키를 클러스터링 키로 생성한다. 그래서 모든 세컨더리 인덱스는 리프 노드에 프라이머리 키 값을 가진다
- 실행계획의 `key_len` 칼럼은 이 쿼리가 인덱스를 구성하는 칼럼 중에서 어느 부분(어느 칼럼)까지 사용했는지를 바이트 수로 보여준다

### 9.3.1.5 인덱스 머지(index_merge)

- 인덱스 머지 실행계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다
  - 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때 MySQL 서버는 인덱스 머지 실행계획을 선택한다
- 인덱스 머지 실행 계획은 다음과 같이 3개의 세부 실행 계획으로 나누어 볼 수 있다
  - index_merge_intersection
  - index_merge_sort_union
  - index_merge_union
- `index_merge`옵티마이저 옵션은 위의 나열된 3개의 최적화 옵션을 한 번에 모두 제어할 수 있는 옵션
