# 08\_인덱스

- CPU, 메모리 -> 전기적 특성을 띤 장치 -> 짧은 시간동안 빠른 속도로 발전
- 디스크 -> 기계식 장치 -> 제한적으로 발전
- 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 많다

## 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- SSD도 기존 하드 디스크 드라이브와 같은 인터페이스(SATA나 SAS)를 지원하므로 내장 디스크나 DAS 또는 SAN에 그대로 사용할 수 있다
- SSD는 기존 디스크 드라이브에서 데이터 저장용 플래터(원판)을 제거하고 플래시 메모리를 장착하고 있다
  - 디스크 원판을 기계적으로 회전시킬 필요가 없으므로 데이터를 빨리 읽고 쓸 수 있다
- 순차I/O에서는 SSD가 HDD보다 조금 빠르거나 거의 비슷한 성능을 보인다
  - 순차I/O: 디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 작업
- SSD는 HDD보다 랜덤 I/O가 훨씬 빠르다
  - 데이터베이스 서버에서 순차 I/O 작업은 비중이 크지 않고 랜덤 I/O를 통한 작업이 대부분이므로 SSD가 DBMS용 스토리지에 적합

## 랜덤 I/O와 순차 I/O

- 디스크에 데이터를 쓰고 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다
  - 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정

## 인덱스

- 비유
  - 찾아보기(색인): 인덱스
  - 책의 내용: 데이터 파일
  - 책의 찾아보기에 적힌 페이지 번호: 데이터 파일에 저장된 레코드의 주소
- 목적: 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그러므로 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-value pair)로 삼아 인덱스를 만들어둔다
- 특징
  - `SortedList`와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태를 유지한다. 반면 데이터 파일은 `ArrayList`와 같이 저장된 순서대로 별도의 정렬 없이 그대로 둔다
  - DBMS에서 인덱스는 데이터의 저장(`INSERT`, `UPDATE`, `DELETE`) 성능을 희생하고 데이터의 읽기 속도를 높이는 기능
- 역할별로 구분
  - 프라이머리 키
  - 보조 키(세컨더리 인덱스)
- 데이터 저장방식(알고리즘)별로 구분
  - `B-Tree` 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
  - `Hash` 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘이다. 매우 빠른 검색을 지원하는 것이 특징이다. 값을 변형하여 인덱싱하므로 값의 일부만 검색하거나 범위를 검색할 때 인덱스를 사용할 수 없다
- 데이터의 중복 허용여부로 분류는 쿼리를 실행하는 옵티마이저에게 중요한 문제가 된다

## B-Tree 인덱스

- B-Tree는 칼럼의 원래 값을 변형시키지 않는다 (값의 앞부분만 잘라 관리)
- 인덱스 구조체 내에서는 항상 정렬된 상태로 유지
- 인덱스의 리프노드는 실제 레코드를 찾아가기 위한 주솟값을 가진다
- InnoDB 테이블의 인덱스와 데이터 파일의 관계: 프라이머리 키가 ROWID 의 역할을 한다
  - InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서 프라이머리 키를 저장하고 있는 B-Tree를 다시 검색해야 한다.

## 인덱스 키 추가

- 비용
  - B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다
  - 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다
  - 리프 노드가 꽉차면 리프노드를 분리해야한다
- InnoDB 스토리지 엔진은 인덱스 키 추가 작업을 지연시킬 수 있다.
  - 프라이머리 키나 유니크 인덱스의 경우에는 중복체크가 필요하므로 즉시 B-Tree에 추가하거나 삭제한다

## 인덱스 키 삭제

- 해당 키 값이 저장된 B-Tree 리프 노드를 찾아 삭제 마크를 한다.
- 마킹 작업 또한 디스크 I/O가 필요한 작업이다
- MySQL 5.5 이상 버전의 InnoDB 스토리지 엔진에서는 삭제 작업도 버퍼링되어 지연 처리할 수 있다

## 인덱스 키 변경

- 인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정된다
- B-Tree 키 값 변경작업은 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다

## 인덱스 키 검색

- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우에 사용할 수 있다.
- 부등호 비교조건에서도 활용할 수 있다
- 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없다
- 키 값에 변형이 가해진 후(함수나 연산을 수행한 결과) 비교되는 작업에 인덱스를 사용할 수 없다
- InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)은 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되있다
  - 따라서 `UPDATE`나 `DELETE` 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. 경우에 따라서는 모든 레코드를 잠글 수도 있다

## 인덱스 키 값의 크기

- 인덱스도 페이지 단위로 관리되며, 노드(루트, 브랜치, 리프노드)를 구분하는 기준이 페이지 단위이다
- 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 따라서 그만큼 느려진다
- 하나의 레코드를 위한 인덱스 크기가 커지면 메모리에 캐시해 둘 수 있는 레코드 수가 줄어든다. 따라서 메모리 효율이 떨어지는 결과를 가져온다

## B-Tree 깊이

- B-Tree 깊이는 MySQL에서 값을 검색할 때 몇번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제이다
- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 따라서 같은 레코드 건수라 하더라도 B-Tree 의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다

## 선택도(기수성)

- 선택도(기수성): 모든 인덱스 키 값 가운데 유니크한 값의 수
- 인덱스는 선택도가 높을수록 검색대상이 줄어들기 때문에 그만큼 빠르게 처리된다
