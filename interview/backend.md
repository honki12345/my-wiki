# 신입 개발자 기술면접 질문 정리 - 백엔드

- <https://dev-coco.tistory.com/163>

## spring framework 에 대해 설명해주세요

- 경량 컨테이너로서 자바 객체를 관리
  - 각각의 객체생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다
- 제어의 역전이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모
  - 컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어 필요에 따라 스프링에서 사용자의 코드를 호출한다
- 의존성 주입을 지원
  - 각각의 계층에서 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다
- 관점지향프로그래밍을 지원
  - 트랜잭션이나 로깅, 보안과 같은 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당기능을 분리하여 관리할 수 있다

## @RequestBody, @RequestParam, @ModelAttribute 의 차이를 설명해주세요

- @RequestParam: binding HTTP request parameters to method arguments
- @ModelAttribute: binding HTTP request parameters to java objects
  값 변환이 아닌 값을 주입시키므로 변수들의 생성자나 getter, setter가 없으면 변수들이 저장되지 않는다
- @RequestBody: converting HTTP request body to java objects
  값을 주입하지 않고 값을 변환시키므로(Reflection을 사용해 할당), 변수들의 생성자, getter, setter 앖어도 정상적으로 할당된다

## spring boot와 spring framework의 차이점을 설명해주세요

- 간결한 설정
  - 스프링부트는 기본적인 설정을 자동으로 처리하므로 개발자가 많은 설정 작업을 하지 않아도 됩니다
- 내장서버
  - 스프링부트는 내장된 서버를 제공하여 별도의 서버 설정 없이 애플리케이션을 실행할 수 있습니다
- 의존성 관리 간소화
  - 스프링부트는 여러 라이브러리를 사용할 때 발생하는 라이브러리 버전 충돌로 인한 문제를 해결하기 위해, 이미 테스트된 여러 라이브러들의 묶음 패키지를 제공합니다
- 운영 편의성
  - 스프링부트는 애플리케이션의 상태 모니터링, 로깅, 보안설정 등 운영에 필요한 기능들을 제공합니다

## Spring MVC에 대해 설명해주세요

- Model은 데이터 관리 및 비즈니스 로직을 처리하는 부분이며
- View는 비즈니스 로직의 처리 결과를 통해 유저 인터페이스가 표현되는 구간입니다
- Controller는 사용자의 요청을 처리하고 Model과 View를 중개하는 역할을 합니다

## MVC는 어떠한 흐름으로 요청을 처리하는지 설명해주세요

- DispatcherServlet: 클라이언트에게 요청을 받아 응답까지의 MVC 처리과정을 통제한다
- HandlerMapping: 클라이언트의 요청 URL을 어떤 controller 가 처리할지 결정한다
- HandlerAdapter: HandlerMapping에서 결정된 핸들러 정보로 해당 메소드를 직접 호출해주는 역할을 한다
- ViewResolver: Controller의 처리 결과(데이터)를 생성할 view를 결정한다
- 1. 클라이언트는 URL를 통해 요청을 전송한다
- 2. 디스패처 서블릿은 핸들러매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다
- 3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다
- 4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다
- 5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다
- 6. 디스패처 서블릿은 뷰리졸버를 통해 반환할 뷰를 찾는다
- 7. 디스패처 서블릿은 컨트롤러에게 뷰에 전달할 데이터를 추가한다
- 8. 데이터가 추가된 뷰를 반환한다

## 제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요

- 제어의 역전이란 모든 객체에 대한 (생성, 라이프싸이클 등) 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것을 말합니다
  스프링에서는 IoC 컨테이너에서 객체들을 생성하면 객체끼리 의존성을 주입하는 역할을 합니다

## 스프링 빈의 라이프사이클은 어떻게 관리되는지 설명해주세요

- 스프링 IoC 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 메소드 호출 -> 사용 -> 소멸 전 콜백 메소드 호출 -> 스프링 종료
- 빈 생명주기 콜백관리
  - 1. 인터페이스(Initializing Bean, DisposableBean)
  - 2. 설정정보에 초기화 메소드, 종료 메소드 지정
  - 3. @PostConstruct, @PreDestroy

## Spring Filter와 Interceptor 에 대해 설명하고 사용 예시를 설명해주세요

- 필터는 요청과 응답을 거르고 정제하는 역할을 합니다
  스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 밖에서 처리됩니다
  Dispatcher Servlet 에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공합니다
  - 사용사례
    - 보안 및 인증/인가 관련 작업
    - 모든 요청에 대한 로깅 또는 검사
    - 이미지/데이터 압축 및 문자열 인코딩
    - spring과 분리되어야 하는 기능
- 인터셉터는 요청에 대한 작업 전/후로 가로채 요청과 응답을 참조하거나 가공하는 역할을 합니다
  웹컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작합니다
  Dispatcher Servlet이 controller 를 호출하기 전/후에 인터셉터가 끼어들어 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공합니다
  - 사용사례
    - 세부적인 보안 및 인증/인가 공통작업
    - API 호출에 대한 로깅 또는 검사
    - Controller로 넘겨주는 정보(데이터)의 가공

## 관점지향프로그래밍(AOP, Aspect Oriented Programming)는 무엇이고, 언제 사용할 수 있을까요?

- AOP는 핵심비즈니스 로직에 있는 공통 관심사항을 분리하여 각각을 모듈화하는 것을 의미하며, 공통 모듈인 인증, 로깅, 트랜잭션 처리에 용이합니다

## Lombok 라이브러리에 대해 알고 있나요? 알고 있다면 롬복이 만드는 메소드들이 생성되는 시점은 언제인가요?

- Lombok은 메소드를 컴파일 하는 과정에 개입해서 추가적인 코드를 만들어냅니다. 이것을 어노테이션 프로세싱이라고 하는데, 어노테이션 프로세싱은 자바 컴파일러가 컴파일 단계에서 어노테이션을 분석하고 처리하는 기법을 말합니다

## 서블릿의 동작 방식에 대해 설명해주세요

- 1. 사용자가 URL을 입력하면 HTTP Request가 Servlet Container로 전송됩니다
- 2. 요청받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성합니다
- 3. web.xml(배포설정자)를 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다
- 4. 해당 서블릿에서 service 메소드를 호출한 후 GET, POST 여부에 따라 doGet() 또는 doPost()를 호출합니다
- 5. doGet() / doPost() 메소드는 동적페이지를 생성한 후 HttpServletResponse 객체에 응답을 보냅니다
- 6. 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다

## VO와 BO, DAO, DTO에 대해 설명해주세요

- DAO(Data Access Object): DB의 데이터에 접근을 위한 객체를 말합니다 (repository, mapper)
- DTO(Data Transfer Object): 각 계층간의 데이터 교환을 위한 객체를 말합니다
- VO(Value Object): 실제 데이터만을 저장하는 객체를 말합니다

## @Transactional 의 동작원리에 대해 설명해주세요

- @Transactional을 메소드 또는 클래스에 명시하면 AOP를 통해 Target이 상속하고 있는 인터페이스 또는 target 객체를 상속한 proxy 객체가 생성되며, proxy 객체의 메소드를 호출하면 target 메소드 전 후로 트랜잭션 처리를 수행합니다

## @Transactional 를 스프링 Bean의 메소드 A에 적용하였고, 해당 Bean 의 메소드 B가 호출되었을 때 B 메소드 내부에서 A 메소드를 호출하면 어떤 요청 흐름이 발생하는지 설명해주세요

- 프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작하며, 타겟 객체의 메소드가 자기자신의 다른 메소드를 호출할 때 프록시가 동작하지 않습니다

## A라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개(다른 service 객체의 트랜잭션 메소드를 호출했다는 의미)가 존재한다고 할 때, @Trancational을 A 메소드에 적용하면 어떤 요청 흐름이 발생하는지 설명해주세요

- 트랜잭션 전파 수준에 따라 달라지는데, 만약 기본 옵션이 Required를 가져간다면 로컬 트랜잭션 3개가 모두 부모 트랜잭션 A에 합류하여 수행됩니다
  그래서 부모 트랜잭션이나 로컬트랜잭션 3개나 모두 같은 트랜잭션이므로 어느 하나의 로직에서 문제가 발생하면 전부 롤백이 됩니다

## @Transactional 에 readOnly 속성을 사용하는 이유에 대해서 설명해주세요

- 트랜잭션 안에서 수정/삭제 작업이 아닌 읽기 작업이 목적인 경우에 주료 사용하며
  영속성 컨텍스트에서 엔티티를 관리할 필요가 없기 때문에 readOnly를 추가하는 것으로 메모리 성능을 높일 수 있고
  데이터 변경 불가능 로직임을 코드로 표시할 수 있어 가독성이 높아진다는 장점이 있습니다
  - readOnly 속성이 없는 트랜잭션은 데이터 조회결과 엔티티가 영속성 컨텍스트에 관리되며
    이는 1차캐싱부터 변경감지(dirty checking)까지 가능하게 만듭니다

## JPA N + 1 문제와 발생하는 이유 그리고 해결하는 방법을 설명해주세요

- N+1 문제란
  - 연관관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n)만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 되는 것
- 해결방안: fetch join
  - fetch join 을 사용하면 미리 두 테이블을 join 하여 한번에 모든 데이터를 가져온다
