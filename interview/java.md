# JVM, GC 관련

## 1. JVM이 무엇인가요?

- JVM은 Java Virtual Machine 의 약어로, 컴파일된 자바 바이트 코드를 실행하는 가상의 운영체제역할을 합니다

## 2. JVM 구조에 대해서 설명해주세요

- JVM은 크게 클래스 로더, 런타임 데이터 영역, 실행 엔진으로 나눌 수 있습니다

## 3. 클래스 로더에 대해 설명해주세요

- 클래스 로더는 런타임동안 JVM의 메소드 영역에 동적으로 Java 클래스를 로드하는 역할을 합니다. 클래스 로더는 로딩, 링크, 초기화 단계로 나뉘어져 있습니다.

## 4. 로딩, 링크, 초기화에 대해 설명해주세요

- **로딩**은 자바 바이트 코드를 메소드 영역에 저장합니다.  
  **링크**는 읽어온 클래스가 문제가 없는지 검사하고, 클래스가 필요한 메모리를 할당하고, 심볼릭 메모리 레퍼런스를 실제 레퍼런스로 교체합니다.
  **초기화**는 클래스를 적절한 값으로 초기화하며, static 필드들이 설정된 값으로 초기화합니다.

## 심볼릭 참조(symbolic reference)와 직접 참조(direct reference)

- 심볼릭 참조란 우리가 코드를 작성하면서 사용한 class, field, method의 이름을 지칭한 것을 말합니다. Resolution 단계에서 class, field, method 그리고 constant pool 의 symbolic references를 실제 메모리 주소로 변환합니다.

## 5. JVM 메모리 구조를 자세히 설명해주세요

- JVM 메모리 구조는 크게 5가지로 나눌 수 있습니다
  - 스레드마다 하나씩 생성되는 공간
    - PC 레지스터
      - 메소드 안에서 바이트 코드 몇번째 줄을 실행하고 있는지와 같은 정보를 갖고 있습니다
    - JVM 스택
      - 새로운 메소드가 호출될 때마다 push, 메소드 실행이 끝나면 pop 동작을 수행합니다
      - 각 스택 프레임에는 지역변수배열, 피연산자 등을 저장하고 있습니다
    - 네이티브 메소드 스택
      - 자바 코드가 아닌 다른 언어로 작성된 네이티브 코드를 위한 스택입니다
  - 모든 스레드가 공유하는 공간
    - 힙
      - 프로그램을 실행하면서 생성된 인스턴스를 저장하는 공간입니다
    - 메소드
      - 클래스 로더가 클래스 파일을 읽어오면 클래스 정보를 파싱하여 필드와 메소드 정보, 메소드의 바이트 코드 등을 저장하는 공간입니다
      - 런타임 상수 풀
        - 메소드 영역 중 하나입니다
        - 각 클래스와 인터페이스의 상수 뿐만 아니라, 메소드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블 입니다.
        - 어떤 메소드나 필드를 참조할 때 런타임 상수 풀을 거쳐야합니다

## 6. JVM 실행 엔진을 설명해주세요

- 실행 엔진은 메모리에 적재된 바이트 코드를 기계어로 변경하여 명령어 단위로 실행하며, 이때 인터프리터와 JIT 방식이 사용됩니다
  - 인터프리터
    - 런타임 중에 바이트 코드를 한 줄씩 읽고 실행합니다
    - 속도가 느립니다
  - JIT
    - 인터프리터의 속도 이슈를 해결하기 위해 같이 사용합니다
    - 자주 실행되는 바이트코드영역을 런타임 중에 기계어로 컴파일하여 사용합니다

## 7. Java의 실행방식을 설명해주세요

1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당 받습니다.
2. 자바 파일이 자바 컴파일러에 의해 자바 바이트코드로 변환됩니다
3. 클래스 로더를 통해 자바 바이트 코드를 JVM으로 필요한 시점에 로딩합니다.
4. 해석된 바이트 코드는 런타임 데이터 영역에 배치되고, 실행 엔진에 의해 실질적인 수행이 이루어지게 됩니다
5. 실행 과정 속에서 JVM은 필요에 따라 GC와 같은 관리 작업을 수행합니다

## 8. JVM의 특징에 대해서 설명해주세요

- Java와 OS 사이에서 중재자 역할을 수행하므로 OS와 무관하게 실행을 보장합니다  
  GC를 통해 프로그램 메모리를 관리하고 최적화합니다

## 9. JVM의 장단점을 설명해주세요

- 장점
  - Java와 OS 사이에서 중재자 역할을 수행하므로 OS와 무관하게 실행을 보장합니다
  - GC를 통해 프로그램 메모리를 자동으로 관리하고 최적화 합니다
- 단점
  - 바이트 코드를 기계어로 바꾸는 과정이 한 번의 컴파일링으로 기계어가 만들어지는 C/C++ 에 비해 속도가 느립니다. 다만 최근에는 JIT를 통해 자주 실행되는 바이트 코드 영역을 컴파일해두기 때문에 속도의 격차를 많이 줄였습니다.

## 10. GC란 무엇인가요?

- GC는 메모리 관리 기법 중 하나로, 동적으로 할당했던 메모리 영역 중 필요없게 된 영역을 해제하는 기능입니다. 여기서 동적으로 할당했던 메모리 영역은 프로그램 런타임에 사용되는 Heap 영역을 뜻하고, 필요없게 된 영역은 어떤 변수도 가리키지 않게 된 영역을 뜻합니다

## 11. GC의 장단점을 설명해주세요

- 장점
  - 메모리를 수동으로 관리하던 것에서 비롯된 에러를 예방할 수 있습니다
    - 개발자의 실수로 인한 메모리 누수, 메모리 이중 해제, 해제된 메모리 접근 등
- 단점
  - GC의 메모리 해제 타이밍을 정확히 알기 어렵습니다
  - 어떠한 메모리 영역이 해제의 대상이 될지 검사하고, 실제로 해제하는 일이 모두 오버헤드에 해당합니다

## 12. GC에서 사용하는 알고리즘은 무엇이 있고, java는 어떤 알고리즘을 사용하나요?

- GC에서 사용하는 알고리즘은 Reference Counting과 Mark And Sweep이 있고, Java에서는 후자를 선택하여 사용합니다
  - Reference Counting
    - 각각의 객체는 몇 가지 방법으로 해당 객체에 접근할 수 있는지 나타내는 Reference Count를 가지고 있고, 이 Count가 0이 된 객체를 메모리에서 해제하는 기법입니다
  - Mark And Sweep
    - Root Space(스택 변수, 정적 변수 등 Heap 영역 참조를 가리키는 공간)부터 그래프 순회를 통해 연결된 객체를 찾아내고, 연결이 끊어진 객체는 메모리에서 해제하는 기법입니다
    - Reference count가 0이 되면 자동으로 지워버리는 reference counting과 다르게 mark and sweep은 의도적으로 특정 순간에 gc를 실행해야 합니다

## 13. GC는 언제 실행되나요? (java 8 기준)

- JVM의 Heap은 Young generation, old generation으로 나뉘고, young generation은 다시 eden, servival 0, servival 1 영역으로 나뉩니다. eden 영역이 꽉 차면 minor gc가 실행되어 mark and sweep 알고리즘을 통해 참조가 되고 있는 객체만 servival 0 또는 servival 1 영역으로 옮깁니다  
  만약 여러 번 minor gc를 실행하고도 참조된 객체가 있다면, 이 객체를 serival 영역에서 old generation으로 옮깁니다. 시간이 지나서 old generation 영역이 꽉 차면 major gc를 실행하여 mark and sweep 알고리즘을 통해 필요 없는 메모리를 비웁니다

## 14. 왜 Heap 영역은 young generation과 old generation으로 나뉘나요?

- 통계적으로 대부분의 객체가 수명이 짧으므로 특정 부분만 탐색함으로써 GC의 성능을 높이기 위해 나누었습니다.

## 15. GC의 실행방식을 모두 설명해주세요

- Serial GC
  - Serial GC는 하나의 스레드로 GC를 실행하는 방식인데, 하나의 스레드로 GC를 실행하다보니 Stop The World 시간이 깁니다
  - GC 실행 이후 메모리 파편화를 막는 Compaction 과정을 수행합니다
- Parallel GC
  - Serial GC를 멀티스레딩으로 수행합니다
- CMS GC
  - 대부분의 가비지 수집 작업을 애플리케이션 스레드와 동시에 수행하여, Stop The World 시간을 최소화하고 있습니다. 하지만 메모리와 CPU를 많이 사용하고, Mark And Sweep 과정 이후 메모리 파편화를 해결하는 Compaction이 기본적으로 제공되지 않는다는 단점이 있습니다
- G1 GC
  - 전통적인 Heap 구조와 달리, G1 GC에서는 Region이라는 논리적 단위로 Young Generation, Old Generation 등으로 쪼개져 있습니다. CMS GC보다 나은 방식으로 애플리케이션과 GC를 동시에 실행할 수 있고, 메모리 Compaction 과정까지 지원하고 있습니다.

## 16. Java 8 디폴트 GC 실행방식은 어떤 것인가요?

- Parallel GC 입니다

## 17. Java 11 디폴트 GC 실행방식은 어떤 것인가요?

- G1 GC입니다

## 18. G1 GC에 대해 설명해주세요

- G1 GC에서 G1은 Garbage First의 약어이며, Garbage만 존재하는 Region을 먼저 회수한다고 해서 붙여진 이름으로, 빈 공간 확보를 빠르게 수행하는 GC입니다

## 19. G1 GC의 장단점을 설명해주세요

- 장점
  - 별도의 STW 없이도 여유 메모리 공간을 압축하는 기능을 제공합니다. 전체 Old Generation 혹은 Young Generation 통째로 Compaction을 할 필요 없고, 해당 Generation의 일부분 Region에 대해서만 Compaction을 하면 됩니다
  - heap 크기가 클수록 잘 동작합니다
  - CMS에 비해 개선된 알고리즘을 사용하고, 처리 속도가 더 빠릅니다
  - Garbage로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로 GC 빈도가 줄어듭니다
- 단점
  - 공간 부족 상태를 조심해야합니다. (Minor GC, Major GC 수행하고 나서도 여유공간이 부족한 경우)
    - 이때는 Full GC가 발생하는데, 이 GC는 Single Thread로 동작합니다
    - Full GC는 heap 전반적으로 GC가 발생하는 것을 뜻합니다
  - 작은 Heap 공간을 가지는 Application 에서는 제 성능을 발휘하지 못하고 Full GC가 발생합니다
  - Humonogous 영역은 제대로 최적화되지 않으므로 해당 영역이 많으면 성능이 떨어집니다

## 20. G1 GC의 Heap 구조를 설명해주세요

- 전통적인 힙 구조는 Young, Old 영역을 명확하게 구분하였지만, G1 GC는 개념적으로 그들이 존재하나 일정 크기의 논리적 단위인 Region 으로 구분하고 있습니다. G1 GC에서는 이 외의 크기가 큰 객체를 저장하는 Humonogous 영역, 아직 사용되지 않은 공간인 Available 영역이 존재합니다
